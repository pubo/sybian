/* Microchip Technology Inc. and its subsidiaries.  You may use this software 
 * and any derivatives exclusively with Microchip products. 
 * 
 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES, WHETHER 
 * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED 
 * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A 
 * PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION 
 * WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION. 
 *
 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
 * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
 * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS 
 * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE.  TO THE 
 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS 
 * IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF 
 * ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
 *
 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE 
 * TERMS. 
 */

/*******************************************************************************
  This source file has NOT been generated by the MHC
 *******************************************************************************/

/* 
 * File:   
 * Author: 
 * Comments:
 * Revision history: 
 */

// *****************************************************************************
// *****************************************************************************
// Section: Included Files 
// *****************************************************************************
// *****************************************************************************
#include <xc.h>
#include "adc.h"
#include "eusart.h"
#include "mcc.h"

// *****************************************************************************
// *****************************************************************************
// Section: Global Data Definitions
// *****************************************************************************
// *****************************************************************************



// *****************************************************************************
// *****************************************************************************
// Section: User Functions
// *****************************************************************************
// *****************************************************************************


// Comment a function definition and leverage automatic documentation 
/**
  <p><b>Function:</b></p>

  <p><b>Summary:</b></p>

  <p><b>Description:</b></p>

  <p><b>Remarks:</b></p>
 */
// TODO Insert function definitions (right here) to leverage live documentation

void doPower(void){
    dev_state = dev_state_init;
    if (pwr_state < pwr_state_max){                                                         // check for 5 cycle
        if (pwr_chk == OFF){                                                      // kick the head
            pwr_chk = ON;
            out_headen = OFF;
            out_pwr = OFF;                                                        // just to make sure VCC = 3V
//            out_headen = 1;
        }
        else {
            if (pwr_tick < pwr_timeout){                                        // check for the initial 102ms pulse
                value_led = ADC_GetConversion(an_led);
                if (value_led < adc_led){
                    pwr_flag = type_heat;
                }
                else {
                    pwr_flag = type_smoke;
                }
            }
            else{
                pwr_state ++;
                pwr_chk = OFF;
                pwr_tick = CLEAR;
            }
        }
    }
    else {
//        if (pwr_flag != 0){
        if (pwr_flag == type_heat){
            dev_type = type_heat;                                               // heat
            out_pwr = ON;
            out_headen = ON;
        }
        else if (pwr_flag == type_smoke){
            dev_type = type_smoke;                                              // smoke
            out_pwr = OFF;
            out_headen = ON;
        }
        else {
            pwr_chk = OFF;
            pwr_tick = CLEAR;
            pwr_state = CLEAR;
            pwr_flag = type_null;
            dev_type = type_null;
            app_state = app_state_init;
        }

        app_state = app_state_runtime;
        dev_state = dev_state_idle;
    }
}

void checkHead(void){
    value_det = ADC_GetConversion(an_det);                                      // check device type
    
    if (value_det <= adc_det){
        out_headen = OFF;
        dev_type = type_null;
        dev_state = dev_state_fault;
    }
    else { 
        if (out_headen == OFF) {
            pwr_flag = OFF;
            app_state = app_state_init;
        }
    }
}

void doSample(void){
    /*--------------Device Part----------------*/
    if (in_horn){
        if (in_test){
            flag_test = ON;
            debounce_horn = CLEAR;
            debounce_idle = CLEAR;
        }
        else {
            flag_horn = ON;
            debounce_horn = CLEAR;
            debounce_idle = CLEAR;
        }
    }
    if ((!in_horn)&&(!in_test)){
        if (debounce_horn < debounce_horn_max){
            debounce_horn ++;
        }
        else {
            flag_horn = OFF;
            flag_test = OFF;
        }
    }
    
//    /*--------------Interconnection Part----------------*/
    value_ict = ADC_GetConversion(an_ict);
    
    if (value_ict > (adc_smoke - adc_gap)){
        if((!flag_horn)&&(!flag_test)){
            if (value_dac == dac_null){                                         // check if ict voltage is supplied by itself
                flag_ict = ON;
                debounce_idle = CLEAR;
            }
        }
    }
    else {
        if (!flag_inh_ict){
            flag_ict = OFF;
            if (dev_state == dev_state_extern){
                dev_state = dev_state_idle;
                debounce_alarm = CLEAR;
            }
        }
    }
    
    app_state = app_state_runtime;
}

void doIO(void){
    /*--------------Interface Part----------------*/
    dev_priority = in_sw1;                                                      // 0: priority 2, 1: priority 1
    out_ioa = in_sw2;                                                        // park unused switch inputs
    out_iob = in_sw3;                                                        // park unused switch inputs
    flag_dummy = in_sw4;                                                        // park unused switch inputs
    
    if (!flag_inh_led){
        if (dev_type > type_null){
            out_led = !ON;
        }
        else {
            out_led = !OFF;

        }
    }

    /*--------------Device Part----------------*/
    if (dev_state < dev_state_alarm){
        if (flag_ict){
            dev_state = dev_state_extern;
            debounce_alarm = CLEAR;
        }
        else {
            if (flag_test){
                dev_state = dev_state_test;
                debounce_alarm = CLEAR;
            }
            else {
                if (flag_horn){
                    if (debounce_alarm > alarm_delay){
                        dev_state = dev_state_alarm;
                    }
                    else {
                        if (debounce_alarm < debounce_alarm_max){
                            debounce_alarm++;
                        }
                    }
                }
            }
        }
    }
    
    if (dev_state >= dev_state_test){
        if (!flag_horn){
            if (!flag_test){
                if(!flag_ict){
                    if (debounce_idle <= debounce_idle_max){
                        debounce_idle ++;
                    }
                    else {
                        dev_state = dev_state_idle;
                        debounce_dac = CLEAR;
                    }
                }
            }
        }
    }

    if (dev_state == dev_state_extern){
        out_ict = ON;
    }
    else {
        out_ict = OFF;
    }
    
    /*--------------Interconnection Part----------------*/
    
//    if ((dev_state == dev_state_alarm)||(dev_state == dev_state_test)){
////        if (value_ict >= (adc_normal - 50)){                                    // don't output below normal threshold. Might be on locate
//        if (dev_type == type_heat){                                             // type heat
//            value_dac = dac_heat;
//        }
//        else {
//            if (dev_priority){                                                  // if set to priority 1
//                value_dac = dac_heat;
//            }
//            else {
//                value_dac = dac_smoke;                                          // type smoke
//            }
//        }        
//    }
//    else {
//        if (dev_state == dev_state_fault){
//            if (dev_state < dev_state_extern){
//                value_dac = dac_mhead;
//            }
//        }
//        else {
//            value_dac = dac_null;
//        }
//    }

    if (dev_state != dev_sstate){
        debounce_dac = CLEAR;                                                   // debounce when there is state change
    }
    
    if ((dev_state == dev_state_alarm)||(dev_state == dev_state_test)){
        if (debounce_dac > dac_delay){
            if (dev_type == type_heat){                                         // type heat
                value_dac = dac_heat;
            }
            else {
                if (dev_priority){                                              // if set to priority 1
                    value_dac = dac_heat;
                }
                else {
                    value_dac = dac_smoke;                                      // type smoke
                }
            }
        }
        else {
            if (debounce_dac < debounce_dac_max){
                debounce_dac ++;
            }
        }
    }
    else {
        if (dev_state == dev_state_fault){
            if (dev_state < dev_state_extern){
                value_dac = dac_mhead;
            }
        }
        else {
            value_dac = dac_null;
        }
    }
    
    DAC1_SetOutput(value_dac);
    dev_sstate = dev_state;
    
    app_state = app_state_runtime;
}

void doState(void){
    switch ( app_state ){
        case app_state_null:                                                    // Prepare Init routine
            dev_state = dev_state_null;
            app_state = app_state_init;
            debounce_dac = CLEAR;
            break;
        case app_state_init:                                                    // Run Init procedures
            doPower();
            debounce_sample = CLEAR;
            debounce_dac = CLEAR;
            flag_inh_led = OFF;
            flag_inh_ict = OFF;
            break;
        case app_state_runtime:                                                    // Idle routine
            checkHead();
            doUART();
            if (app_state == app_state_runtime){
                if (debounce_io >= io_period){
                    app_state = app_state_io;
                    debounce_io = CLEAR;
                }
                else {
                    if (debounce_sample >= sample_delay){
                        app_state = app_state_sample;
                    }
                    else {
                        debounce_sample ++;
                        debounce_dac = CLEAR;                                   
                    }
                }
            }
            break;
        case app_state_sample:
            doSample();
            break;
        case app_state_io:
            doIO();
            break;
        default:
            app_state = app_state_null;
            break;
    }
}

void doUART(void){
    if (print_flag){
        sprintf(uart_tx_buffer, "\n\rICT = %d, DAC = %d, RX = %d\n\r" ,value_ict, value_dac, value_uart);
        for(s_tx_ptr = uart_tx_buffer; *s_tx_ptr; s_tx_ptr++){
            EUSART_Write(*s_tx_ptr);
        }
        sprintf(uart_tx_buffer, "State = %d, Type = %d, H%d, T%d, I%d\n\r" ,dev_state, dev_type, flag_horn, flag_test, flag_ict);
        for(s_tx_ptr = uart_tx_buffer; *s_tx_ptr; s_tx_ptr++){
            EUSART_Write(*s_tx_ptr);
        }
        print_flag = CLEAR;
    }

    if(eusartRxCount!=0){
        rx_byte = EUSART_Read();

        if ((rx_byte < 58)&&(rx_byte > 47)){                                // check if receive data is numbers
            uart_rx_buffer[rx_ptr] = rx_byte;                               // write the received char into the array
            rx_ptr++;
        }
        else if (rx_byte == 0x0D){                                          // break out when reach CR character
            value_uart = doAtoi(uart_rx_buffer);                            // convert the received string to number
            rx_ptr = 0;                                                     // reset array pointer
            cleanArray(uart_rx_buffer);                                     // purge array
        }
        else if (rx_byte == 'A'){
            flag_ict ^= ON;
            flag_inh_ict ^= ON;
        }
        else if (rx_byte == 'L'){
            out_led ^= ON;
            flag_inh_led ^= ON;
        }
        else if (rx_byte == 'P'){
            print_flag = SET;
        }
        else if (rx_byte == 'S'){
            value_dac = value_uart;
        }
        
        rx_byte = CLEAR;
    }
}
/*
void doComms(void){
    unsigned char temp, data, index;
    if (!BufferIsEmpty()){
        temp = getElement();
        if (temp != 0){
            index = (temp & mask_index);
            data = (temp & mask_data);
            switch (index){
                case offset_master_cmd:
                    uart_rx_cmd = data;
                    switch (uart_rx_cmd){
                        case ENQ:
                            if (rx_ptr >= 1){
                                EUSART_Write(dev_address | offset_slave_addr);
                                rx_ptr++;
                                EUSART_Write((EOL_Flag << 4)|(dev_priority << 3)|(dev_state)|offset_slave_stat);
                                rx_ptr++;
                                EUSART_Write(EOT | offset_slave_cmd);
                                rx_ptr++;
                            }
                            break;
                        case BEL:
                            EUSART_Write(dev_address | offset_slave_addr);
                            break;
//                            case REQ:
//                                break;
//                            case INT:
//                                break;
//                            case ASG:
//                                break;
                        case ACT1:
                            if (dev_priority){
                                if (debounce_act1 >= 8){
                                    dev_state = dev_state_extern;
                                    debounce_act1 = 0;
                                }
                                else {
                                    debounce_act1++;
                                }
                            }
                            break;
                        case ACT2:
                            if (!dev_priority){
                                if (debounce_act2 >= 8){
                                    dev_state = dev_state_extern;
                                    debounce_act2 = 0;
                                }
                                else {
                                    debounce_act2++;
                                }
                            }
                            break;
                        case CAN:
                            if (debounce_can >= 8){
                                dev_state = dev_state_idle;
                                debounce_can = 0;
                            }
                            else {
                                debounce_can++;
                            }
                            break;                            
                        default:
                            break;
                    }
                    break;
                case offset_master_addr:
                    rx_ptr = 0;
                    if ((dev_address == 0)&&(dev_state == dev_state_init)){
                        dev_address = data;
                        EUSART_Write((EOL_Flag << 4)|(dev_priority << 3)|(dev_state)|offset_slave_stat);
                        EUSART_Write(EOT | offset_slave_cmd);
                        dev_state = dev_state_idle;
                    }
                    if (dev_address == data){
                        EUSART_Write(dev_address | offset_slave_addr);          // resend its own address to acknowledge
                        rx_ptr = 1;                                             // check next value on buffer if it is for this device
                    }
                    break;
//                case offset_master_type:
//                    break;
//                case offset_reserve:
//                    break;
                default:
                    break;
            }
        }
    }
}
*/

void cleanArray(char *var){
    int i = 0;
    while(var[i] != '\0') {
        var[i] = '\0';
        i++;
    }
}

int doAtoi(char *str){
    int res = 0; // Initialize result
  
    // Iterate through all characters of input string and
    // update result
    for (int i = 0; str[i] != '\0'; ++i)
        res = res*10 + str[i] - '0';
  
    // return result.
    return res;
}

//EOF